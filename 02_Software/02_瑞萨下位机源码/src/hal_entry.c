#include "app.h"
#include "drv_adc.h"
#include <devices.h>
#include <drivers.h>
#include <errno.h>
#include <libs.h>
#include "hal_data.h"
#include <stdio.h>
#include "./devices/LCD/font.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

char Data_Stream[128];
Data_Value Data;
char str[100];

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
/*--------- 测试函数 ---------*/
//	WiFiBtAppTest();
//	DeviceTest();
//	BH1750Test();
//	DispAppTest();
//	ADCAppTest();
//	BreathingLights();

/*--------- 网络鉴权数据 ---------*/
	int ret1,ret2;
	int ret3;
	
/*--------- 外设初始化 ---------*/
	UartDevicesRegister();
    TimerDevicesRegister();
    IODevicesRegister();
	GptPWMDrvInit();

	//土壤湿度
	ADCDevTypeDef *ptMHDev = MHGetDevice();
    if(NULL == ptMHDev)
    {
        printf("Error. Not found ADC device!\r\n");
        return;
    }
    printf("Success to find ADC device: %s-%d\r\n", ptMHDev->name, ptMHDev->channel);
    ptMHDev->Init(ptMHDev);
	
	//气体传感器
	ADCDevTypeDef *ptMQDev = MQGetDevice();
    if(NULL == ptMQDev)
    {
        printf("Error. Not found ADC device!\r\n");
        return;
    }
    printf("Success to find ADC device: %s-%d\r\n", ptMQDev->name, ptMQDev->channel);
    ptMQDev->Init(ptMQDev);
	
	//PH传感器
	ADCDevTypeDef *ptPHDev = PHGetDevice();
    if(NULL == ptPHDev)
    {
        printf("Error. Not found ADC device!\r\n");
        return;
    }
    printf("Success to find ADC device: %s-%d\r\n", ptPHDev->name, ptPHDev->channel);
    ptPHDev->Init(ptPHDev);
	
	//DHT11
	DHT11Device *pDevice = DHT11GetDevice();
    if(NULL == pDevice)
    {
        printf("Error. There is no DHT11 device!\r\n");
        return;
    }
    pDevice->Init(pDevice);
	
	//按键
	struct IODev *ptKeyDev = IOGetDecvice("UserKey");
    if(NULL == ptKeyDev)
    {
        printf("Failed to get UserKey!\r\n");
        return;
    }
	ptKeyDev->Init(ptKeyDev);
	
	//BH1750
	BH1750_IIC_Init();
	printf("BH1750 OK!\r\n");
	
	//TFT屏
	DispApp_Init();

/*--------- 网络连接 ---------*/
	ConnectInfo connect = {
        .Protocl = TCP,
        .Role = Client,
        .IP = "183.230.40.40",
        .RemotePort = 1811,
        .LocalPort = 4687
    };
	char *TCP_Info = "*632605#198018#test*\r\n";
	
	WiFiTCP_Init(&ret1, &ret2, connect, TCP_Info);

/*--------- 执行代码 ---------*/
    while(1)
    {
		if(ret1 != ESUCCESS)	//重新联网
        {
            xprintf("Failed to connect net!\r\n");
            ret1 = WiFiBtDevConnect(&connect);
			R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
        }
		else if(ret2 != ESUCCESS)	//重新连接服务器
		{
			xprintf("Failed to ENTM!\r\n");
			ret2 = TCP_Connect(connect, TCP_Info);
			R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
		}
		else
		{
			/*--------- ADC数据采集 ---------*/
			Data.MHvalue = MHData(ptMHDev);	//土壤湿度
			Data.MQvalue = MQData(ptMQDev);	//空气质量
			Data.PHvalue = PHData(ptPHDev);	//PH值
		
			/*--------- 光强数据采集 ---------*/
			Data.Light = BH1750Data();
		
			/*--------- 环境温湿度数据采集 ---------*/
			DeviceData(pDevice);
			Data.temp = pDevice->tempture;
			Data.humi = pDevice->humidity;
		
			/*--------- 数据整合 ---------*/
			sprintf(Data_Stream,"T%dH%dL%.2fM%.2fS%.2f\r\n",	\
								Data.temp, \
								Data.humi, \
								Data.Light, \
								Data.MQvalue, \
								Data.MHvalue);
	
			/*--------- 数据上传 ---------*/
			ret3 = TCP_Data(Data_Stream);

			/*------- 执行命令 --------*/
			PWM_LED(Data);	//	调光
			
			KeyProcessJitter();	//测试按键
			KeyProcessMotor();	//SW1--驱动电机
			KeyProcessWater();	//SW2--驱动水泵
			KeyProcessWind();	//SW3--驱动风扇
			
			/*--------- TFT显示 ---------*/
			ST7735_DrawString(36, 0, "Smart", Font_11x18, ST7735_GREEN, ST7735_BLACK);
			ST7735_DrawString(25, 18, "Flowers", Font_11x18, ST7735_GREEN, ST7735_BLACK);
		
			ST7735_DrawString(0, 40, "Temp: ", Font_7x10, ST7735_WHITE, ST7735_BLACK);
			sprintf(str, "%d", Data.temp);
			ST7735_DrawString(43, 40, str, Font_7x10, ST7735_WHITE, ST7735_BLACK);
			ST7735_DrawString(64, 40, "Humi: ", Font_7x10, ST7735_WHITE, ST7735_BLACK);
			sprintf(str, "%d", Data.humi);
			ST7735_DrawString(108, 40, str, Font_7x10, ST7735_WHITE, ST7735_BLACK);
		
			ST7735_DrawString(0, 66, "LUX: ", Font_7x10, ST7735_WHITE, ST7735_BLACK);
			sprintf(str, "%.2f", Data.Light);
			ST7735_DrawString(36, 66, str, Font_7x10, ST7735_WHITE, ST7735_BLACK);
			ST7735_DrawString(64, 66, "Gas: ", Font_7x10, ST7735_WHITE, ST7735_BLACK);
			sprintf(str, "%.2f", Data.MQvalue);
			ST7735_DrawString(92, 66, str, Font_7x10, ST7735_WHITE, ST7735_BLACK);
		
			ST7735_DrawString(0, 92, "Soil: ", Font_7x10, ST7735_WHITE, ST7735_BLACK);
			sprintf(str, "%.2f", Data.MHvalue);
			ST7735_DrawString(43, 92, str, Font_7x10, ST7735_WHITE, ST7735_BLACK);
			ST7735_DrawString(64, 92, "PH: ", Font_7x10, ST7735_WHITE, ST7735_BLACK);
			sprintf(str, "%.2f", Data.PHvalue);
			ST7735_DrawString(92, 92, str, Font_7x10, ST7735_WHITE, ST7735_BLACK);
			
		
			mdelay(50);
		}
    }
	
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
